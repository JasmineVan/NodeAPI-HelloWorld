'use strict';

var iconv = require('iconv-lite'),
	is = require('type-is').is,
	mime = require('mime-types'),
	util = require('mini-util');

	// Message constructor.
var Message = util.inherit(Function, {
	/**
	 * Constructor.
	 * @param config {Object}
	 */
	constructor: function (config) {
		// Private data stores here.
		Object.defineProperty(this, '__', {
			value: {
				headers: config.headers || {},
				charset: config.charset || 'utf-8'
			}
		});
		
		this.data(config.data || new Buffer(0));
	},

	/**
	 * Get/Set the message encoding.
	 * @param [value] {string}
	 * @return {string|Object}
	 */
	charset: function (value) {
		var __ = this.__;
	
		if (util.isUndefined(value)) { // Getter.
			return __.charset;
		} else { // Setter.
			__.charset = Object(value).toString();
			return this;
		}
	},

	/**
	 * Get/Set the message data.
	 * @param [value] {string|Buffer|Array}
	 * @return {Buffer|Object}
	 */
	data: function (value) {
		var __ = this.__;
	
		if (util.isUndefined(value)) { // Getter.
			return Buffer.concat(__.data, __.length);
		} else { // Setter.
			if (!util.isArray(value)) {
				value = [ value ];
			}
			
			var charset = __.charset,
				length = 0,
				len = value.length,
				i = 0;
				
			for (; i < len; ++i) {
				if (!util.isBuffer(value[i])) {
					value[i] = iconv.encode(
						Object(value[i]).toString(), charset);
				}
				length += value[i].length;
			}
			
			__.data = value;
			__.length = length;
			
			return this;
		}
	},

	/**
	 * Get/Set the message header fields.
	 * @param [key] {string|Object}
	 * @param [value] {string|Array}
	 * @return {string|Object}
	 */
	head: (function () {
		function normalize(value) {
			if (util.isArray(value)) {
				var len = value.length,
					i = 0;
					
				for (; i < len; ++i) {
					value[i] = Object(value[i]).toString();
				}
			} else {
				value = Object(value).toString();
			}
			
			return value;
		}
	
		return function (key, value) {
			var headers = this.__.headers;
		
			if (util.isObject(key)) { // Set multiple fields.
				var obj = key,
					keys = Object.keys(obj),
					len = keys.length,
					i = 0;
				
				for (; i < len; ++i) {
					key = keys[i];
					value = normalize(obj[key]);
					headers[key] = value;
				}
				
				return this;
			} else if (util.isUndefined(key)) { // Get all fields.
				// Make a copy.
				return util.merge(headers);
			} else if (util.isUndefined(value)) { // Get one field.
				return headers[key] || '';
			} else { // Set one field.
				headers[key] = normalize(value);
				return this;
			}
		};
	}()),
	
	/**
	 * Infer the contnet-type.
	 * @param ... {string}
	 * @return {string|boolean}
	 */
	is: function () {
		return is(this.head('content-type'), util.toArray(arguments));
	},
	
	/**
	 * Convert binary data to string.
	 * @return {string}
	 */
	toString: function () {
		var charset = this.__.charset,
			data = this.__.data,
			len = data.length,
			i = 0,
			str = '';
			
		for (; i < len; ++i) {
			str += iconv.decode(data[i], charset);
		}
		
		return str;
	},
	
	/**
	 * Get/Set the message type.
	 * @param [key] {string|Object}
	 * @param [value] {string|Array}
	 * @return {string|Object}
	 */
	type: function (value) {
		if (value) { // Setter.
			value = mime.contentType(value) || '';
			
			if (value.indexOf('charset=') !== -1) {
				value = value.split(';')[0] + '; charset=' + this.charset();
			}
			
			this.head('content-type', value);
			
			return this;
		} else { // Getter.
			return this.head('content-type').split(';')[0];
		}
	}
});

module.exports = Message;
