'use strict';

var util = require('mini-util'),
	g = require('./util/g'),
	wildcard = require('./util/wildcard');

var PATTERN_GENERATOR = /^function\s?\*/;

// Pipeline constructor.
var	Pipeline = util.inherit(Object, {
	/**
	 * Constructor.
	 * @param config {Object}
	 */
	constructor: function (config) {
		this._hostname = config.hostname;
		this._pathname = config.pathname;
		this._filters = [];
	},
	
	/**
	 * Compile the generator.
	 * @param filter {Function}
	 * @return {Function}
	 */
	_compile: function (filter) {
		return PATTERN_GENERATOR.test(filter.toString()) ?
			g(filter) : filter;
	},

	/**
	 * Check whether current pipeline has a higher priority.
	 * @param rival {Object}
	 * @return {number}
	 */
	compareTo: function (rival) {
		var a = this,
			b = rival;

		// Negative returning value has lower array index.
		// If a has higher array index, reutrn -1.
		// If a and b have the same priority, return 0.
		// If a has lower array index, return 1.

		// Compare hostname first.
		if (a._hostname > b._hostname) {
			return -1;
		} else if (a._hostname === b._hostname) {
			// If hostname is equal, compare pathname.
			if (a._pathname > b._pathname) {
				return -1;
			} else if (a._pathname === b._pathname) {
				// If all equal, index unchanged.
				return 0;
			} else {
				return 1;
			}
		} else {
			return 1;
		}
	},

	/**
	 * Check whether current mount point matches the request.
	 * @param req {Object}
	 * @return {boolean}
	 */
	match: function (req) {
		var hostname = req.hostname,
			pathname = req.pathname;

		// Match hostname at first.
		if (!wildcard(this._hostname, hostname)) {
			return false;
		}

		// Match pathname at last.
		if (!wildcard(this._pathname, pathname)) {
			return false;
		}

		return true;
	},

	/**
	 * Process a request.
	 * @param req {Object}
	 * @param res {Object}
	 * @param callback {Function}
	 */
	process: function (req, res, callback) {
		var queue = this._filters;

		(function move(i, callback) {
			if (i < queue.length) {
				var fn = queue[i],
	
					next = function (callback) {
						// You can move forward any times.
						move(i + 1, callback);
					},

					done = function (err) {
						if (err && !util.isError(err)) { // Normalize.
							err = new Error(String(err));
						}
						// You can move back only once.
						if (fn = callback) { // Assign.
							callback = null;
							fn(err);
						}
					};
				
				next.__proto__ = req;
				done.__proto__ = res;
				
				fn(next, done, done);
			} else {
				callback();
			}
		}(0, callback));
	},
	
	/**
	 * Use a filter.
	 * @filter {Function}
	 */
	use: function (filter) {
		this._filters.push(this._compile(filter));
	}
});

module.exports = Pipeline;
