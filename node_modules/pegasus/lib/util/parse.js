'use strict';

var iconv = require('iconv-lite'),
	path = require('path'),
	util = require('mini-util');

var PATTERN_HREF =
		/^(\w+:)?(?:\/\/)?([^\/\?]+@)?([^\/\?\:]+?)?(:\d+)?(\/[^\?]*)?(\?.*)?$/,

	PATTERN_BOUNDARY = /boundary=(.*?)(?:;.*)?$/,

	PATTERN_HEADER = /^([\w\-]+)\s*:\s*(.*)$/,

	PATTERN_NAME = /name="(.*?)"/,

	PATTERN_FILENAME = /filename="(.*?)"/,
	
	PATTERN_NEWLINE = /\r?\n/;

/**
 * Append multiple values to the same key.
 * @param obj {Object}
 * @param key {string}
 * @param value {*}
 */
function append(obj, key, value) {
	if (!obj.hasOwnProperty(key)) {
		obj[key] = value;
	} else if (util.isArray(obj[key])) {
		obj[key].push(value);
	} else {
		obj[key] = [ obj[key], value ];
	}
}

/**
 * Find first positon in binary of given string.
 * @param bin {Buffer}
 * @param str {string}
 * @param startAt {number}
 * @return {number}
 */
function indexOf(bin, str, startAt) {
	str = new Buffer(str, 'ascii');

	var len1 = str.length,
		len2 = bin.length - len1 + 1,
		i, j;
		
	for (j = startAt || 0; j < len2; ++j) {
		for (i = 0; i < len1; ++i) {
			if (str[i] !== bin[j + i]) {
				break;
			} else if (i === len1 - 1) {
				return j;
			}
		}
	}
	
	return -1;
}

/**
 * Split multipart body by boundary.
 * @param bin {Buffer}
 * @param boundary {string}
 * @return {Array}
 */
function split(bin, boundary) {
	var len = boundary.length + 2, // Bounary length includes CRLF.
		start = 0,
		middle = 0,
		end = 0,
		parts = [],
		part;

	while (true) {
		start = indexOf(bin, boundary + '\r\n', end);
		end = start === -1 ? -1 : indexOf(bin, '\r\n' + boundary, start + len);

		if (end > start) {
			part = bin.slice(start + len, end);
			middle = indexOf(part, '\r\n\r\n');
			parts.push({
				head: part.slice(0, middle),
				body: part.slice(middle + 4)
			});
		} else {
			break;
		}
	}

	return parts;
}

/**
 * A much faster URL parser than the native one.
 * @param url {string}
 * @return {Object}
 */
var url = exports.url = function (url) {
	var re = url.match(PATTERN_HREF) || {},
		obj = {};

	obj.protocol = re[1] || '';
	obj.auth = re[2] ? re[2].split('@')[0] : '';
	obj.host = (re[3] || '') + (re[4] || '');
	obj.port = re[4] ? re[4].split(':')[1] : ''
	obj.hostname = re[3] || '';
	obj.search = re[6] || '';
	obj.query = re[6] ? query(re[6].substring(1)) : {};
	obj.pathname = re[5] || '';
	obj.path = re[5] + (re[6] || '');
	obj.href = url;

	return obj;
};

/**
 * A much faster query string parser than the native one.
 * @param query {string}
 * @param [delimiter] {string|RegExp}
 * @return {Object}
 */
var query = exports.query = function (query, delimiter) {
	var obj = {},
		parts = query.split(delimiter || '&'),
		i = 0,
		len = parts.length,
		kv, k, v;

	for (; i < len; ++i) {
		kv = parts[i].split('=');
		k = kv[0];
		v = decodeURIComponent(kv[1] || '');

		if (typeof obj[k] === 'undefined') {
			obj[k] = v;
		} else if (typeof obj[k] === 'string') {
			obj[k] = [ obj[k], v ];
		} else {
			obj[k].push(v);
		}
	}

	return obj;
};

/**
 * Parse multipart data.
 * @param bin {Buffer}
 * @param parameters {string}
 * @param charset {string}
 * @return {Object|null}
 */
var multipart = exports.multipart = function (bin, parameters, charset) {
	var obj = {},
		re = parameters.match(PATTERN_BOUNDARY),
		boundary;

	if (!re) { // Boundary missed.
		return null;
	}

	// Prefix boundary with "--".
	boundary = '--' + re[1];

	split(bin, boundary).forEach(function (part) {
		var head = {},
			body = part.body,
			re,
			name,
			contentType;
		
		// Parse headers.
		iconv.decode(part.head, charset).split('\r\n')
			.forEach(function (value) {
				if (re = value.trim().match(PATTERN_HEADER)) {
					head[re[1].toLowerCase()] = re[2];
				}
			});

		if (re = head['content-disposition'].match(PATTERN_NAME)) {
			name = re[1];
			contentType = head['content-type'];

			if (!contentType) { // Text field doesn't has content-type header.
				body = iconv.decode(body, charset);
			} else { // File field.
				body.mime = contentType;
				if (re = head['content-disposition'].match(PATTERN_FILENAME)) {
					body.filename = path.basename(re[1]);
				}
			}

			append(obj, name, body);
		}
	});

	return obj;
};

/**
 * Parse form data.
 * @param data {Buffer}
 * @param type {string}
 * @param charset {string}
 * @return {Object}
 */
var form = exports.form = function (data, type, charset) {
	type = type.split(';');

	var mime = type[0],
		parameters = (type[1] || '').trim(),
		obj;

	switch (mime) {
	case 'application/x-www-form-urlencoded':
		data = iconv.decode(data, charset);
		obj = query(data);
		break;
	case 'text/plain':
		data = iconv.decode(data, charset);
		obj = query(data, PATTERN_NEWLINE);
		break;
	case 'multipart/form-data':
		obj = multipart(data, parameters, charset);
		break;
	}
	
	return obj || {};
};
